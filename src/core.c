#include <stdio.h>
#include "../includes/core.h"
#include <stdlib.h>
#include <string.h>

#define SIZE 500

// Init dynamic solution

int max(int a, int b) { return (a > b) ? a : b; }

void knapSack(int **K, int W, int wt[], int val[], int n, Island *islands) {
    int i, j, w;

    for (i = 0; i <= n; i++) {
        for (w = 0; w <= W; w++) {
            if (i == 0 || w == 0)
                K[i][w] = 0;
            else if (wt[i - 1] <= w)
                K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w]);
            else
                K[i][w] = K[i - 1][w];
        }
    }

	i = n;
	j = W;
    int days = 0;
	while(i >= 1) {
		if(K[i][j] != K[i-1][j]) {
			days++;
			j = (int)(j-islands[i-1].cost);
		}
		i--;
	}

    printf("%d %d\n", K[n][W], days);
}

void initDynamicSoluction(Island *islands, int N, int M, int *costs, int *pontuations) {
    int i;
    int **K = (int**)calloc(M + 1, sizeof(int*)); 
    for (i = 0; i < M + 1; i++) 
        K[i] = (int*)calloc(N + 1, sizeof(int)); 

    knapSack(K, N, costs, pontuations, M, islands);

    for (i = 0; i < M; i++) {
        free(K[i]);
    }
    free(K);
}

// Finish Dynamic solution

// Init greedy solution
void merge(Island *arr, int l, int m, int r) { 
	int i, j, k; 
	int n1 = m - l + 1; 
	int n2 = r - m; 

	Island L[n1], R[n2]; 

	for (i = 0; i < n1; i++) 
		L[i] = arr[l + i]; 
	for (j = 0; j < n2; j++) 
		R[j] = arr[m + 1+ j]; 

	i = 0; 
	j = 0; 
	k = l; 
	while (i < n1 && j < n2) { 
		if (L[i].custoPerPontuation <= R[j].custoPerPontuation) { 
			arr[k] = L[i]; 
			i++; 
		} 
		else { 
			arr[k] = R[j]; 
			j++; 
		} 
		k++; 
	} 

	while (i < n1) { 
		arr[k] = L[i]; 
		i++; 
		k++; 
	} 

	while (j < n2) { 
		arr[k] = R[j]; 
		j++; 
		k++; 
	} 
} 

void mergeSort(Island *arr, int l, int r) { 
	if (l < r) { 
		int m = l+(r-l)/2; 
		mergeSort(arr, l, m); 
		mergeSort(arr, m+1, r); 
		merge(arr, l, m, r); 
	} 
} 

void calcTripInformations(Island *islands, int budget, int numberOfIslands) {
    int pontuation = 0, days = 0, spent = 0, i;

    for (i = 0; i < numberOfIslands; i++) {
        int dayQtd = (budget - spent) / islands[i].cost;
        days += dayQtd;
        pontuation += islands[i].pontuation * dayQtd;
        spent += islands[i].cost * dayQtd;
    }
    printf("%d %d\n", pontuation, days);
}

void initGreedSoluction(Island *islands, int N, int M, int *costs, int *pontuations) {
	mergeSort(islands, 0, M - 1); 
    calcTripInformations(islands, N, M);
} 

// finish greedy solution 

void fillObject(Island *islands, int *costs, int *pontuations, int size) {
    int i;
    for (i = 0; i < size; i++) {
        islands[i].cost = costs[i];
        islands[i].pontuation = pontuations[i];
        islands[i].custoPerPontuation = (double)costs[i] / (double)pontuations[i];
    }
}

void initProgram (FILE *file) {
    // Leitura de dados

    // Variaveis com as informações informação:
    // N -> valor máximo a ser gasto
    // M -> número de ilhas
    int N, M, *costs, *pontuations;

    int charCtrl = 0, infoCtrl = 0;
    char linhaAlfanumerica[SIZE], *info;

    // Extração de informações:

    while(fscanf(file, "%s", linhaAlfanumerica) != EOF) {
        info = strtok(linhaAlfanumerica, " ");
        while (info != NULL) {
            if (charCtrl == 0) { // Valor máximo a ser gasto
                N = atoi(info);
                if (!N) { return; }
            }
            else if (charCtrl == 1) { // Númemro de ilhas
                M = atoi(info);
                if (!M) { return; }
                costs = (int*)calloc(M, sizeof(int));
                pontuations = (int*)calloc(M, sizeof(int));
            }
            else if (charCtrl > 1) { // custos e pontuações
                if (charCtrl % 2 == 0) { // Custo da i-esima ilha
                    costs[infoCtrl] = atoi(info);
                } else { // Pontuação da i-esima ilha
                    pontuations[infoCtrl] = atoi(info);
                    infoCtrl++;
                }
            }
            charCtrl++;
            info = strtok(NULL, " ");
        }

    }

    // Fill structures and find solutions

    Island *greedIslands;
    greedIslands = (Island*)calloc(M, sizeof(Island));
    fillObject(greedIslands, costs, pontuations, M);
    initGreedSoluction(greedIslands, N, M, costs, pontuations);

    // We have to create another structure to prevent errors generated by mergesort
    Island *dynamicIsland;
    dynamicIsland = (Island*)calloc(M, sizeof(Island));
    fillObject(dynamicIsland, costs, pontuations, M);
    initDynamicSoluction(dynamicIsland, N, M, costs, pontuations);

    // Free memory
    free(costs);
    free(pontuations);
    free(greedIslands);
    free(dynamicIsland);
}